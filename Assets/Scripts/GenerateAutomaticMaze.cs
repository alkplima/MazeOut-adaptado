using System;
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic; 
using System.Linq;
using System.IO;

public class GenerateAutomaticMaze : Singleton<SaveHandler>
{
    public GameObject grid;
    public GameObject handGear;

    private int maxColumns, maxRows;
    private string[,] gridMatrix;
    private float minX, maxX, minY, maxY, timePerCoinBottomToTop, timePerCoinTopToBottom, timePerCoinLeftToRight, timePerCoinRightToLeft;
    int xMaxColumnIndex, yMaxCellIndex, xMinColumnIndex, yMinCellIndex;
    private int maxCellGrowth = 1;

    void OnEnable()
    {
        if (VariaveisGlobais.partidaCorrente == 2001)
        {
            GenerateAutomaticMazeFromCalibration();
        }
    }

    private void GenerateAutomaticMazeFromCalibration()
    {
        ResetGridMatrix();
        ProcessCalibrationData();
        GenerateMaze();
        LoadAutoGeneratedMaze();
    }

    private void ResetGridMatrix()
    {
        for (int j = 0; j < maxColumns; j++)
        {
            for (int i = 0; i < maxRows; i++)
            {
                gridMatrix[i, j] = null;
            }
        }
    }

    // TODO: Implementar análise dos dados de calibração considerando as 8 fases
    private void ProcessCalibrationData()
    {
        minX = VariaveisGlobais.minX;
        maxX = VariaveisGlobais.maxX;
        minY = VariaveisGlobais.minY;
        maxY = VariaveisGlobais.maxY;
        timePerCoinBottomToTop = VariaveisGlobais.timePerCoinBottomToTop;
        timePerCoinTopToBottom = VariaveisGlobais.timePerCoinTopToBottom;
        timePerCoinLeftToRight = VariaveisGlobais.timePerCoinLeftToRight;
        timePerCoinRightToLeft = VariaveisGlobais.timePerCoinRightToLeft;
    }

    private void GenerateMaze() 
    {
        // Tamanho da matrix que representará o novo grid
        maxRows = grid.transform.GetChild(0).childCount;
        maxColumns = grid.transform.childCount;
        gridMatrix = new string[maxRows, maxColumns];

        // Índices das colunas e células que delimitam o novo grid personalizado
        int[] limitIndexes = GetGridLimitsFromCalibrationCoordinates();
        xMaxColumnIndex = limitIndexes[0];
        yMaxCellIndex = limitIndexes[1];
        xMinColumnIndex = limitIndexes[2];
        yMinCellIndex = limitIndexes[3];

        DrawRectangle();
        


        for (int colIndex = xMinColumnIndex; colIndex < xMaxColumnIndex; colIndex++)
        {
            for (int rowIndex = yMinCellIndex; rowIndex < yMaxCellIndex; rowIndex++)
            {
                // TODO: Lógica para gerar o labirinto no espaço limitado


            }
        }

        // Percorre uma última vez garantindo que não tem espaço vazio
        for (int colIndex = 0; colIndex < maxColumns; colIndex++)
        {
            for (int rowIndex = 0; rowIndex < maxRows; rowIndex++)
            {
                if (gridMatrix[rowIndex, colIndex] == null) // Checa célula vazia
                {
                    gridMatrix[rowIndex, colIndex] = "Tiles_0"; // preenche com parede cinza
                }
            }
        }
    }

    private int[] GetGridLimitsFromCalibrationCoordinates()
    {
        int xMaxColumnIndex = -1;
        int yMaxCellIndex = -1;
        int xMinColumnIndex = -1;
        int yMinCellIndex = -1;
        bool foundXMax = false;
        bool foundXMin = false;
        bool foundYMax = false;
        bool foundYMin = false;

        // Procura a coluna que tem o maxX e a coluna que tem o minX
        for (int col = 0; col < maxColumns; col++)
        {
            Transform column = grid.transform.GetChild(col);
            float cellWidth = column.GetComponent<RectTransform>().rect.width; // largura da célula

            // Verifica se a coluna tem o maxX
            if (!foundXMax && maxX >= column.transform.position.x - cellWidth / 2 && maxX <= column.transform.position.x + cellWidth / 2) 
            {
                xMaxColumnIndex = IndexWithRandomGrowth(col, false, true);
                foundXMax = true;
            } 
            // Verifica se a coluna tem o minX
            else if (!foundXMin && minX >= column.transform.position.x - cellWidth / 2 && minX <= column.transform.position.x + cellWidth / 2) 
            {
                xMinColumnIndex = IndexWithRandomGrowth(col, true, true);
                foundXMin = true;
            }

            if (foundXMax && foundXMin) 
            {
                break;
            }
        }

        // Procura a célula que tem o maxY e a célula que tem o minY
        if (xMaxColumnIndex != -1 && xMinColumnIndex != -1) 
        {
            for (int cel = 0; cel < maxRows; cel++)
            {
                Transform cell = grid.transform.GetChild(0).GetChild(cel);
                float cellHeight = cell.GetComponent<RectTransform>().rect.height; // altura da célula

                // Verifica se a célula tem o maxY
                if (!foundYMax && maxY >= cell.transform.position.y - cellHeight / 2 && maxY <= cell.transform.position.y + cellHeight / 2) 
                {
                    yMaxCellIndex = IndexWithRandomGrowth(cel, true, false);
                    foundYMax = true;
                }
                // Verifica se a célula tem o minY
                else if (!foundYMin && minY >= cell.transform.position.y - cellHeight / 2 && minY <= cell.transform.position.y + cellHeight / 2) 
                {
                    yMinCellIndex = IndexWithRandomGrowth(cel, false, false);
                    foundYMin = true;
                }

                if (foundYMax && foundYMin) 
                {
                    break;
                }
            }
        }

        return new int[] { xMaxColumnIndex, yMaxCellIndex, xMinColumnIndex, yMinCellIndex };
    }

    public int IndexWithRandomGrowth(int index, bool shouldDecreaseToGrow, bool isColumn)
    {
        // Checa se o índice já está no limite do grid
        if (index == 0 || (isColumn && index==maxColumns - 1) || (!isColumn && index==maxRows - 1)) 
        {
            return index;
        }

        int cellGrowth = UnityEngine.Random.Range(0, maxCellGrowth + 1);
        if (shouldDecreaseToGrow) // Índice negativo → deve subtrair para crescer 
        {
            return index - cellGrowth;
        }
        return index + cellGrowth;
    }

    private void DrawRectangle()
    { 
        // Início aleatório, mas colado em uma das paredes
        int xStartIndex = UnityEngine.Random.Range (xMinColumnIndex, xMaxColumnIndex + 1);
        int yStartIndex = (xStartIndex == xMinColumnIndex || xStartIndex == xMaxColumnIndex) ? UnityEngine.Random.Range (yMinCellIndex, yMaxCellIndex + 1) : (UnityEngine.Random.Range (0, 2) == 0 ? yMinCellIndex : yMaxCellIndex);
        gridMatrix[yStartIndex, xStartIndex] = "start";
    }

    private void LoadAutoGeneratedMaze() 
    {
        int j = 0; 
        foreach (Transform col in grid.transform) {
            int i = 0;
            foreach (Transform cel in col.transform) {
                // Limpa informações anteriores
                cel.SetLocalPositionAndRotation(cel.localPosition, new Quaternion(0, 0, 0, 0));
                cel.gameObject.tag = "Untagged";

                if (cel.gameObject.TryGetComponent<BlocoImpeditivo>(out BlocoImpeditivo bloco))
                    Destroy(bloco);
                if (cel.gameObject.TryGetComponent<Rigidbody2D>(out Rigidbody2D rigid))
                    Destroy(rigid);
                if (cel.gameObject.TryGetComponent<BoxCollider2D>(out BoxCollider2D box))
                    Destroy(box);
                if (cel.gameObject.TryGetComponent<Coin>(out Coin coin))
                    Destroy(coin);

                // Povoa com o que precisa
                cel.gameObject.GetComponent<CelulaInfo>().selecionadoSprite = Resources.Load<Sprite>("Sprites" + Path.DirectorySeparatorChar + gridMatrix[i, j]);
                cel.GetComponent<UnityEngine.UI.Image>().sprite = cel.gameObject.GetComponent<CelulaInfo>().selecionadoSprite;
                if (gridMatrix[i, j].StartsWith("Tiles"))
                {
                    cel.gameObject.AddComponent<BlocoImpeditivo>();
                    cel.gameObject.AddComponent<Rigidbody2D>();
                    cel.gameObject.GetComponent<Rigidbody2D>().gravityScale = 0;
                    cel.gameObject.AddComponent<BoxCollider2D>();
                    cel.gameObject.GetComponent<BoxCollider2D>().size = new Vector2(57, 57);
                    cel.gameObject.GetComponent<BoxCollider2D>().isTrigger = true;
                }
                else if (gridMatrix[i, j].StartsWith("static")) 
                {
                    cel.gameObject.AddComponent<Coin>();
                    cel.gameObject.AddComponent<Rigidbody2D>();
                    cel.gameObject.GetComponent<Rigidbody2D>().gravityScale = 0;
                    cel.gameObject.AddComponent<BoxCollider2D>();
                    cel.gameObject.GetComponent<BoxCollider2D>().isTrigger = true;
                    cel.gameObject.GetComponent<BoxCollider2D>().size = new Vector2(57, 57);
                }
                else if (gridMatrix[i, j].StartsWith("start"))
                {
                    cel.gameObject.tag = "Start";
                    handGear.transform.position = cel.transform.position;
                    handGear.SetActive(true);
                }
                else if (gridMatrix[i, j].StartsWith("finish")) 
                {
                    cel.gameObject.AddComponent<FinalizouPartida>();
                    cel.gameObject.AddComponent<Rigidbody2D>();
                    cel.gameObject.GetComponent<Rigidbody2D>().gravityScale = 0;
                    cel.gameObject.AddComponent<BoxCollider2D>();
                    cel.gameObject.GetComponent<BoxCollider2D>().size = new Vector2(57, 57);
                    cel.gameObject.GetComponent<BoxCollider2D>().isTrigger = true;
                }
                // else if (data[i].selecionadoSprite.ToString().StartsWith("check")) {
                //     cel.gameObject.AddComponent<CheckPoint>();
                // }
                // else if (data[i].selecionadoSprite.ToString().StartsWith("vazio")) {}
                // else {
                //     Debug.Log("Sprite não reconhecido: "+data[i].selecionadoSprite.ToString()

                // }
                i++;
            }
            j++;
        }
    }
}